/*
[결합 알고리즘과 성능]
* 옵티마이저가 선택 가능한 결합 알고리즘은 크게 다음의 세 가지가 존재
  * 1. Nested Loops
  * 2. Hash
  * 3. Sort Merge
* 옵티마이저는 데이터 크기 또는 결합 키의 분산이라는 요인에 의해 알고리즘을 선택

1. Nested Loops
* 본질적으로 이중 반복을 의미
  * 한 테이블(구동 테이블/ 외부 테이블)의 레코드마다 결합하는 다른 테이블(내부 테이블)의 레코드를 하나씩 스캔해서 결합 조건에 맞으면 리턴
  * 따라서, Nested Loops의 실행 시간은 레코드 수에 비례
* 한 번의 단계에서 처리하는 레코드 수가 적어 Hash 또는 Sort Merge에 비해 메모리 소비가 적음
* 모든 DBMS에서 지원
* 구동 테이블이 작을수록 Nested Loops의 성능이 좋아짐
  * 단, 내부 테이블의 결합 키 필드에 인덱스가 존재해야 함
    * 이떄, 결합 키가 유일(Unique)하면 내부 반복을 완전히 생략 가능
    * 유일하지 않으면 내부 반복의 완전한 생략은 불가능함
* 초기 단계부터 ER 모델과 인덱스를 설정할 때 어떤 테이블을 내부 테이블로 하고, 어떤 결합 키에 인덱스를 작성해야 하는지 고민 해야 함
* 만약 앞서 언급한, 내부 테이블의 결합 키가 유일하지 않은 경우 다음 2가지 해결 방법이 존재
  * 구동 테이블로 큰 테이블을 선택해, 극단적으로 성능이 저하되는 것을 막음
    * 구동 테이블의 크기가 현실적인 범위 이내여야 함
  * 해시

2. Hash 
* 다음의 방식으로 작동
  * 작은 테이블로 스캔 후, 결합 키에 해시 함수를 적용해서 해시값으로 반환
  * 이어서 결합할 다른 (상대적으로) 큰 테이블을 스캔하고 결합 키가 해시값에 존재하는지 확인한 후 조건에 맞으면 결합을 수행
* Nested Loops에 비해 메모리를 크게 소모
* 메모리가 부족하면 저장소를 사용하므로 지연이 발생
* 출력되는 해시값은 입력값의 순서를 알지 못하므로, 등치 결합에만 사용 가능
* Hash가 유용한 경우
  * 적절한 구동 테이블, 즉 상대적으로 충분히 작은 테이블이 존재하지 않는 경우
  * 구동 테이블로 사용할 작은 테이블은 있지만, 내부 테이블의 결합 키가 유일하지 않으며 레코드 수가 너무 많은 경우
  * 애초에 내부 테이블에 인덱스가 존재하지 않는 경우
* Hash 고려사항
  * 서비스에서는 OLTP(사용자 요구에 시스템이 곧바로 응대합해야하는 처리)가 많은 경우 메모리가 부족해져 지연이 발생할 수 있으므로 부적절한 전략임
  * Hash를 위해 양쪽 테이블의 레코드를 전부 읽어야 하므로, 테이블의 규모가 굉장히 크다면 풀 스캔에 걸리는 시간을 고려해야 함

3. Sort Merge
* 결합 대상 테이블들을 각각 결합 키로 정렬하고 일치하는 결합 키를 찾으면 결합함
* 대상 테이블을 모두 정렬해야 하므로 Nested Loops보다 많은 메모리가 소비됨
* 규모에 따라 다르지만, Hash는 한쪽 테이블에 대해서만 해시 테이블을 만드므르 Hash보다 많은 메모리를 사용하기도 함(이로 인해 지연이 발생할 가능성이 높음)
* Hash와 다르게 동치 결합 뿐만 아니라 부등호를 사용한 결합에도 사용할 수 있음
  * 단 부정 조건 결합에서는 사용할 수 없음(부정 조건 결합은 Nested Loops만 사용 가능)
* 테이블이 결합 키로 정령되어 있다면 정렬을 택할 수 있음
  * 다만 이는 SQL에서 테이블에 있는 레코드의 물리적인 위치를 알고 있을 경우에 한정됨(즉, DB의 구현에 의존함)
* 테이블을 정렬해야하므로 한쪽 테이블을 모두 스캔한 시점에 결합을 완료할 수 있음

4. 의도하지 않은 크로스 결합
* 테이블 세개(A, B, C)를 결합할 때 다음의 상황에서 발생할 수 있음
  * A와 B그리고 A와 C 사이에 결합 키가 있지만, B와 C 사이에 결합 키가 존재하지 않는 경우
  * B와 C의 크기가 작은 경우
  * 큰 테이블에서 2번 결합하는 것보다, 작은 테이블을 결합하고 1번 결합하는 것이 합리적일 수 있음
* 만약 이를 회피하고 싶다면 B와 C 테이블에 결합 조건을 설정해주면 됨(맞지 않으니 결과에는 영향 없음)
*/
