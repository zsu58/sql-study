/*
[결합이 느리다면]
1. 상황에 따른 최적의 결합 알고리즘
* Nested Loops, Hash, Sort Merge 장단점 정리
  * Nested Loops
    * 장점
      * 작은 구동 테이블 + 내부 테이블의 인덱스라는 조건이 있다면 굉장히 빠름
      * 메모리 또는 디스크 소비가 적으므로 OLTP에 적합
      * 비등가 결합에서도 사용 가능
    * 단점
      * 대규 모 테이블들의 결합에는 부적합
      * 내부 테이블의 인덱스가 없거나, 선택률이 높으면 느림
  
  * Hash
    * 장점
      * 대규모 테이블들을 결합할 떄 적합
    * 단점
      * 메모리 소비량이 큰 OLTP에는 부적합
      * 메모리 부족이 일어나면 TEMP 탈락 발생
      * 등가 결합에서만 사용 가능
  
  * Sort Merge
    * 장점
      * 대규모 테이블들을 결합할 떄 적합
      * 비등가 결합에서도 사용 가능
    * 단점
      * 메모리 소비량이 큰 OLTP에는 부적합
      * 메모리 부족이 일어나면 TEMP 탈락 발생
      * 데이터가 정렬되어 있지 않다면 비효율적

* 결합 대상 레코드 수의 관점에서 적합한 알고리즘
  * 소규모 - 소규모
    * 어떤 알고리즘을 사용해도 성능 차이가 크지 않음
  * 소규모 - 대규모
    * 소규모 테이블을 구동 테이블로 하는 Nested Loops를 사용(단, 인덱스 키가 필요)
    * 내부 테이블의 결합 대상 레코드 수가 너무 많다면 구동 테이블과 내부 테이블을 바꾸거나, Hash를 사용해볼 것을 고려
  * 대규모 - 대규모
    * 일단 Hash를 사용
    * 결합 키로 처음분터 정렬되어 있다면 Sort Merg를 사용
* 기본적으로는 Nested Loops, 잘 안되면 Hash 사용

2. 실행 계획 제어
* Oracle
  * 힌트 구(USE_NL, USE_HASH, USE_MERGE)
  * 구동 테이블 지정(LEADING)
* Microsoft SQL SERVER
  * 힌트 구(LOOP, HASH, MERGE)
* DB2
  * 힌트 구가 없으며, 원치적으로 사용자가 실행 계획 제어 못함
* Postgres
  * pg_hint_plan
  * 서버 매개변수로 데이터베이스 전체를 제어(enable_nestloop, enable_hashjoin, enable_mergejoin)
* MySQL
  * 결합 알고리즘 자체가 Nested Loops 계열 밖에 없으므로 선택의 여지 없음(cf. 2018년 8월 이후 나온 8.0버전 이후부터는 지원)
* 다만, 시점에 따라 실행 계획이 달라질 수 있으므로 사람의 판단으로 실행 계획을 고정시켜 버리는 것은 리스크일 수 있음
  * 따라서, 데이터의 특성을 바탕으로 시간에 따라 데이터의 변화를 유사적으로 모방하고 성능 테스트를 실시 해야 함

3. 흔들리는 실행 계획
* 데이터 증가 등의 이유로 통계 정보가 변했을 떄 일정한 역치를 넘으면 옵티마이저가 실행 계획을 안 좋은 방향으로 변화시키기도 함
  * cf. 애플리케이션을 튜닝하거나, 하드웨어 리소스를 증가(주로 저장소 I/O 비용과 메모리 부족 떄문에 발생)시키는 방법이 존재
*/
